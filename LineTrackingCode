//ELEC 299 Final Project Teams 16, 17, 18
#include <Servo.h>
#include <EEPROM.h> 
#include <QSerial.h>
Servo servo1Pan, servo2Tilt, servo3Grip;

//Digital Pins
#define bumpL    2
#define bumpR    3
#define motorL   4
#define speedL   5
#define motorR   7
#define speedR   6
#define button   8
#define encodeL  12
#define encodeR  13

//Analog Pins
#define IRead A0
#define grip A1
#define frontIR A2
#define leftIR A3
#define centreIR A4
#define rightIR A5

//ASCII Character Definitions
#define L        76
#define C        67
#define R        82

//Initial Values for Team 17
#define LTHRESH17 900
#define CTHRESH17 900
#define RTHRESH17 900
byte  left_speed  = 160;
byte  right_speed = 160;
bool speed_locked17;
int centerSe = 0;
int rightSe  = 0;
int leftSe = 0;
#define DELTA     5

//Initial Variables
int   grip_angle  = 40; 
int   theChar     = 0;
int   start_position = 0;
int   counterL = 0;
int   counterR = 0;
int   aStateL = 0;
int   aLastStateL = 0;
int   aStateR = 0;
int   aLastStateR = 0;
String ccFlag = "none";


 int countEncoderL(){
    aStateL = digitalRead(encodeL); // Reads the "current" state of the outputA
   // If the previous and the current state of the outputA are different, that means a Pulse has occured
   if (aStateL != aLastStateL){     
     // If the outputB state is different to the outputA state, that means the encoder is rotating clockwise
     if (digitalRead(encodeL) != aStateL) { 
       counterL ++;
     } else {
       counterL ++;
     }
     Serial.print("PositionL: ");
     Serial.println(counterL);
   } 
   aLastStateL = aStateL;
   return counterL;
 }

  int countEncoderR(){
   aStateR = digitalRead(encodeR); // Reads the "current" state of the outputA
   // If the previous and the current state of the outputA are different, that means a Pulse has occured
   if (aStateR != aLastStateR){     
     // If the outputB state is different to the outputA state, that means the encoder is rotating clockwise
     if (digitalRead(encodeR) != aStateR) { 
       counterR ++;
     } else {
       counterR ++;
     }
     Serial.print("PositionR: ");
     Serial.println(counterR);
   } 
   aLastStateR = aStateR;
   return counterR;
 }

void courseCorrect()
{
  bool lDetect, cDetect, rDetect;
  lDetect = analogRead(leftIR)>LTHRESH17;
  cDetect = analogRead(centreIR)>CTHRESH17;
  rDetect = analogRead(rightIR)>RTHRESH17;
  if(cDetect && !lDetect && !rDetect)
  {
    ccFlag="none";
    return;
  }
  else if(ccFlag=="none")
  {
    if(lDetect && !rDetect)
    {
      ccFlag="left";
      right_speed = right_speed + (255-right_speed+3)/4;
      left_speed = left_speed - (left_speed)/4;
      analogWrite(speedR, right_speed);
      analogWrite(speedL, left_speed);
    }
    else if(rDetect && !lDetect)
    {
      ccFlag="right";
      left_speed = left_speed + (255-left_speed+3)/4;
      right_speed = right_speed - (right_speed)/4;
      analogWrite(speedR, right_speed);
      analogWrite(speedL, left_speed);
    }
  }
  else if(ccFlag=="left")
  {
    if(!lDetect)
    {
      ccFlag="hard_left";
      right_speed = right_speed + (255-right_speed+3)/3*2;
      left_speed = left_speed - (left_speed)/3*2;
      analogWrite(speedR, right_speed);
      analogWrite(speedL, left_speed);
    }
    else if(!rDetect)
    {
      ccFlag="hard_right";
      left_speed = left_speed + (255-left_speed+3)/3*2;
      right_speed = right_speed - (right_speed)/3*2;
      analogWrite(speedR, right_speed);
      analogWrite(speedL, left_speed);
    }
  }
}

void turnAdjustR(){
  countEncoderL();
  countEncoderR();
}

void lineAdjust(){
  countEncoderL();
  countEncoderR();
  if(counterL > counterR){
  digitalWrite(motorR, HIGH);
  analogWrite(speedR, 155);
  digitalWrite(motorL, LOW);
  analogWrite(speedL, 0);
  }
  else if(counterL < counterR){
  digitalWrite(motorR, LOW);
  analogWrite(speedR, 0);
  digitalWrite(motorL, HIGH);
  analogWrite(speedL, 155);
  }
  else{
   digitalWrite(motorR, HIGH);
  analogWrite(speedR, 155);
  digitalWrite(motorL, HIGH);
  analogWrite(speedL, 155); 
  }
}

void turnAdjustL(){
  countEncoderL();
  countEncoderR();
}

//Make robot go backwards
void backup() {
  digitalWrite(motorR, LOW);
  analogWrite(speedR, 155);
  digitalWrite(motorL, LOW);
  analogWrite(speedL, 0);
  if(leftIR == LTHRESH17 && centreIR == CTHRESH17 && rightIR == RTHRESH17){
  analogWrite(speedL, 0);
  analogWrite(speedR, 0);
  }
}

//Make robot go forwards
void forward() {
  int forward_state = 0;
  courseCorrect();
  centerSe = analogRead(centreIR);
  rightSe = analogRead(rightIR);
  leftSe = analogRead(leftIR);
  digitalWrite(motorR, HIGH);
  analogWrite(speedR, 125);
  digitalWrite(motorL, HIGH);
  analogWrite(speedL, 125);
  while(forward_state == 0){
  courseCorrect();
  centerSe = analogRead(centreIR);
  rightSe = analogRead(rightIR);
  leftSe = analogRead(leftIR);
  lineAdjust();
  if(leftSe > LTHRESH17){
  digitalWrite(motorR, HIGH);
  analogWrite(speedR, 140);
  digitalWrite(motorL, HIGH);
  analogWrite(speedL, 100);
  }
  if(rightSe> RTHRESH17){
  digitalWrite(motorR, HIGH);
  analogWrite(speedR, 100);
  digitalWrite(motorL, HIGH);
  analogWrite(speedL, 140);  
  }
  if(leftSe > LTHRESH17 && centerSe > CTHRESH17 && rightSe > RTHRESH17){
    delay(500);
  analogWrite(speedL, 0);
  analogWrite(speedR, 0);
  forward_state = 1;
  counterR = 0;
  counterL = 0;
  delay(1000);
  }
  
  }
}

void small_forward(){
  centerSe = analogRead(centreIR);
  rightSe = analogRead(rightIR);
  leftSe = analogRead(leftIR);
  digitalWrite(motorR, HIGH);
  analogWrite(speedR, 125);
  digitalWrite(motorL, HIGH);
  analogWrite(speedL, 125);
  delay(50);
}

//Make robot go left
void left() {
  int forward_state = 0;
  turnAdjustL();
  centerSe = analogRead(centreIR);
  rightSe = analogRead(rightIR);
  leftSe = analogRead(leftIR);
  digitalWrite(motorR, HIGH);
  analogWrite(speedR, 125);
  digitalWrite(motorL, LOW);
  analogWrite(speedL, 125);
  while(forward_state == 0){
  centerSe = analogRead(centreIR);
  rightSe = analogRead(rightIR);
  leftSe = analogRead(leftIR);
  turnAdjustL();
  if( counterL == 12 || counterR == 12){
  analogWrite(speedL, 0);
  analogWrite(speedR, 0);
  forward_state = 1;
  counterR = 0;
  counterL = 0;
  delay(1000);
  }
  
  }
}

void small_left(){
  centerSe = analogRead(centreIR);
  rightSe = analogRead(rightIR);
  leftSe = analogRead(leftIR);
  digitalWrite(motorR, HIGH);
  analogWrite(speedR, 125);
  digitalWrite(motorL, LOW);
  analogWrite(speedL, 125);
  delay(250);
}

//Make robot go right
void right() {
  int forward_state = 0;
  turnAdjustR();
  centerSe = analogRead(centreIR);
  rightSe = analogRead(rightIR);
  leftSe = analogRead(leftIR);
  digitalWrite(motorR, LOW);
  analogWrite(speedR, 125);
  digitalWrite(motorL, HIGH);
  analogWrite(speedL, 125);
  while(forward_state == 0){
  centerSe = analogRead(centreIR);
  rightSe = analogRead(rightIR);
  leftSe = analogRead(leftIR);
  turnAdjustR();
  if(counterL == 12 || counterR == 12){
  analogWrite(speedL, 0);
  analogWrite(speedR, 0);
  forward_state = 1;
  counterR = 0;
  counterL = 0;
  delay(1000);
  } 
  }
}

void small_right(){
  centerSe = analogRead(centreIR);
  rightSe = analogRead(rightIR);
  leftSe = analogRead(leftIR);
  digitalWrite(motorR, LOW);
  analogWrite(speedR, 125);
  digitalWrite(motorL, HIGH);
  analogWrite(speedL, 125);
  delay(250);
}

//Make the robot take a 180 degree turn, needs to be completed
void fullTurn(){
  small_right();
  right();
  small_right();
  right();
  //delay until sometime and continue
}

//Collision Detection Code
/*void ReactBumpers() { //Need to revise for the competition
  if (!digitalRead(bumpL) && !digitalRead(bumpR)) {
    Backup();
    delay(1000);
    digitalWrite(motorL, HIGH);
    digitalWrite(motorR, LOW);
    analogWrite(speedR, 105);
    analogWrite(speedL, 100);
    delay(1500);
  } 
  else if (digitalRead(bumpL) && !digitalRead(bumpR)) {
    Backup();
    delay(1000);
    digitalWrite(motorL, LOW);
    digitalWrite(motorR, HIGH);
    analogWrite(speedR, 105);
    analogWrite(speedL, 100);
    delay(1000);
  } 
  else if (!digitalRead(bumpL) && digitalRead(bumpR)){
    Backup();
    delay(1000);
    digitalWrite(motorL, HIGH);
    digitalWrite(motorR, LOW);
    analogWrite(speedR, 105);
    analogWrite(speedL, 100);
    delay(1000);
  }
  else{}
}*/

//Determine the correct motor speed for your robot
void adjustSpeeds()
{
  int adjustSpeedsState = 0;
  while(adjustSpeedsState == 0)
  if(!digitalRead(bumpL) || !digitalRead(bumpR))
    delay(250); //give user time to get the other bumper pressed too
  if(!digitalRead(bumpL) && digitalRead(bumpR))
  {
    left_speed-=DELTA;
    right_speed+=DELTA;
    Serial.println("increasing right, decreasing left");
  }
  else if(digitalRead(bumpL) && !digitalRead(bumpR))
  {
    left_speed+=DELTA;
    right_speed-=DELTA;
    Serial.println("increasing left, decreasing right");
  }
  //user indicates we're going straight now
  else if(!digitalRead(bumpL) && !digitalRead(bumpR))
  {
    
    Serial.println("comitting speed changes");
    EEPROM.write(0, left_speed);  //save left speed to EEPROM address 0
    EEPROM.write(1, right_speed); //save right speed to EEPROM address 1
    right_speed = left_speed = 0; //set wheel speeds to zero to stop Bot
    delay(100);
    adjustSpeedsState =1;
  }
}

//Waits for a button to be pressed, and then released. Used as start button for robot
void WaitButton(){
   int state = 0;
   while(state <= 1)
  {
    if (!digitalRead(button))
    {
      delay(100);
      if (!digitalRead(button))
      state = 1;
    }
    else if (state==1)
    {
      if (digitalRead(button))
      state=2;
    }
  }
}

//Grabs an object, and then waits until both bumpers are hit to release the ball
void grab() {
  grip_angle++;
  servo3Grip.write(grip_angle);
  if(digitalRead(grip) >= 500){ //Need to change the value to compare -- just need to check if the gripper is sensing something
    while(bumpL == 0 || bumpR ==0){
    }
   grip_angle == 180;
   servo3Grip.write(grip_angle);
   delay(25);
  }
  
  
  delay(25);
 
  if( grip_angle >= 170){
    while(grip_angle >= 40){
      grip_angle--;
      servo3Grip.write(grip_angle);
      delay(20);
    }
  }
}

//Determines the starting position of the robot, need to write
void whichStart() {/*
  int no_start = 0;
  while(no_start == 0){
   if IR sensor reads L
      start_position = 1;
      no_start = 1;
   else if if IR sensor reads C
      start_position = 2;
      no_start = 1;
   else if IR sensor reads R
      start_position = 3;
      no_start = 1;
      
  }*/
}

void setup() {
  //Declarations
  Serial.begin(9600);
  servo3Grip.attach(9);
  servo2Tilt.attach(10);  
  servo1Pan.attach(11);
  servo1Pan.write(110);
  servo2Tilt.write(70);
  servo3Grip.write(40);
  pinMode(motorL,OUTPUT);
  pinMode(motorR,OUTPUT);
  pinMode(speedL,OUTPUT);
  pinMode(speedR,OUTPUT);
  pinMode(button,INPUT);
  pinMode(bumpL,INPUT);
  pinMode(bumpR,INPUT);
  pinMode(encodeL,INPUT);
  pinMode(encodeR,INPUT);
  analogWrite(speedR,  0);
  analogWrite(speedL,  0);
  WaitButton();
  speed_locked17 = false;
  
}

void loop() {
int cycle = 0; // Used to be able to make sure that no collisions occur

//If we are using the hard coding method, this will be the format we will use.
/*switch(cycle){
  case //number
    if(start_position == 1){
      //path
     }
     
     else if(start_position == 2){
     //second path
     }

    else //Third Start Position{
      // third path
     }
  */
   forward();
   fullTurn();
}

  

